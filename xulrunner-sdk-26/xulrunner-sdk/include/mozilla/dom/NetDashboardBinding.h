/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#ifndef mozilla_dom_NetDashboardBinding_h__
#define mozilla_dom_NetDashboardBinding_h__

#include "mozilla/ErrorResult.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/DOMJSClass.h"
#include "mozilla/dom/DOMJSProxyHandler.h"

namespace mozilla {
namespace dom {

struct HalfOpenInfoDict;
struct HttpConnInfoDict;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

struct ConnStatusDict : public MainThreadDictionaryBase
{
  Optional<nsString > mStatus;

private:
  static bool initedIds;
  static jsid status_id;

  ConnStatusDict(const ConnStatusDict&) MOZ_DELETE;

public:
  inline ConnStatusDict()
  {
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

private:
  static bool
  InitIds(JSContext* cx);
};
struct ConnStatusDictInitializer : public ConnStatusDict
{
  inline ConnStatusDictInitializer()
  {
    // Safe to pass a null context if we pass a null value
    Init(nullptr, JS::NullHandleValue);
  }
};


struct DNSCacheDict : public MainThreadDictionaryBase
{
  Optional<Sequence<double > > mExpiration;
  Optional<Sequence<nsString > > mFamily;
  Optional<Sequence<Sequence<nsString > > > mHostaddr;
  Optional<Sequence<nsString > > mHostname;

private:
  static bool initedIds;
  static jsid expiration_id;
  static jsid family_id;
  static jsid hostaddr_id;
  static jsid hostname_id;

  DNSCacheDict(const DNSCacheDict&) MOZ_DELETE;

public:
  inline DNSCacheDict()
  {
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

private:
  static bool
  InitIds(JSContext* cx);
};
struct DNSCacheDictInitializer : public DNSCacheDict
{
  inline DNSCacheDictInitializer()
  {
    // Safe to pass a null context if we pass a null value
    Init(nullptr, JS::NullHandleValue);
  }
};


struct DNSLookupDict : public MainThreadDictionaryBase
{
  Optional<Sequence<nsString > > mAddress;
  Optional<bool > mAnswer;
  Optional<nsString > mError;

private:
  static bool initedIds;
  static jsid address_id;
  static jsid answer_id;
  static jsid error_id;

  DNSLookupDict(const DNSLookupDict&) MOZ_DELETE;

public:
  inline DNSLookupDict()
  {
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

private:
  static bool
  InitIds(JSContext* cx);
};
struct DNSLookupDictInitializer : public DNSLookupDict
{
  inline DNSLookupDictInitializer()
  {
    // Safe to pass a null context if we pass a null value
    Init(nullptr, JS::NullHandleValue);
  }
};


struct HalfOpenInfoDict : public MainThreadDictionaryBase
{
  Optional<Sequence<bool > > mSpeculative;

private:
  static bool initedIds;
  static jsid speculative_id;

  HalfOpenInfoDict(const HalfOpenInfoDict&) MOZ_DELETE;

public:
  inline HalfOpenInfoDict()
  {
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

private:
  static bool
  InitIds(JSContext* cx);
};
struct HalfOpenInfoDictInitializer : public HalfOpenInfoDict
{
  inline HalfOpenInfoDictInitializer()
  {
    // Safe to pass a null context if we pass a null value
    Init(nullptr, JS::NullHandleValue);
  }
};


struct HttpConnInfoDict : public MainThreadDictionaryBase
{
  Optional<Sequence<nsString > > mProtocolVersion;
  Optional<Sequence<uint32_t > > mRtt;
  Optional<Sequence<uint32_t > > mTtl;

private:
  static bool initedIds;
  static jsid protocolVersion_id;
  static jsid rtt_id;
  static jsid ttl_id;

  HttpConnInfoDict(const HttpConnInfoDict&) MOZ_DELETE;

public:
  inline HttpConnInfoDict()
  {
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

private:
  static bool
  InitIds(JSContext* cx);
};
struct HttpConnInfoDictInitializer : public HttpConnInfoDict
{
  inline HttpConnInfoDictInitializer()
  {
    // Safe to pass a null context if we pass a null value
    Init(nullptr, JS::NullHandleValue);
  }
};


struct SocketsDict : public MainThreadDictionaryBase
{
  Optional<Sequence<bool > > mActive;
  Optional<Sequence<nsString > > mHost;
  Optional<Sequence<uint32_t > > mPort;
  double mReceived;
  double mSent;
  Optional<Sequence<double > > mSockreceived;
  Optional<Sequence<double > > mSocksent;
  Optional<Sequence<uint32_t > > mTcp;

private:
  static bool initedIds;
  static jsid active_id;
  static jsid host_id;
  static jsid port_id;
  static jsid received_id;
  static jsid sent_id;
  static jsid sockreceived_id;
  static jsid socksent_id;
  static jsid tcp_id;

  SocketsDict(const SocketsDict&) MOZ_DELETE;

public:
  inline SocketsDict()
  {
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

private:
  static bool
  InitIds(JSContext* cx);
};
struct SocketsDictInitializer : public SocketsDict
{
  inline SocketsDictInitializer()
  {
    // Safe to pass a null context if we pass a null value
    Init(nullptr, JS::NullHandleValue);
  }
};


struct WebSocketDict : public MainThreadDictionaryBase
{
  Optional<Sequence<bool > > mEncrypted;
  Optional<Sequence<nsString > > mHostport;
  Optional<Sequence<uint32_t > > mMsgreceived;
  Optional<Sequence<uint32_t > > mMsgsent;
  Optional<Sequence<double > > mReceivedsize;
  Optional<Sequence<double > > mSentsize;

private:
  static bool initedIds;
  static jsid encrypted_id;
  static jsid hostport_id;
  static jsid msgreceived_id;
  static jsid msgsent_id;
  static jsid receivedsize_id;
  static jsid sentsize_id;

  WebSocketDict(const WebSocketDict&) MOZ_DELETE;

public:
  inline WebSocketDict()
  {
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

private:
  static bool
  InitIds(JSContext* cx);
};
struct WebSocketDictInitializer : public WebSocketDict
{
  inline WebSocketDictInitializer()
  {
    // Safe to pass a null context if we pass a null value
    Init(nullptr, JS::NullHandleValue);
  }
};


struct HttpConnDict : public MainThreadDictionaryBase
{
  Optional<Sequence<HttpConnInfoDict > > mActive;
  Optional<Sequence<HalfOpenInfoDict > > mHalfOpens;
  Optional<Sequence<nsString > > mHost;
  Optional<Sequence<HttpConnInfoDict > > mIdle;
  Optional<Sequence<uint32_t > > mPort;
  Optional<Sequence<bool > > mSpdy;
  Optional<Sequence<bool > > mSsl;

private:
  static bool initedIds;
  static jsid active_id;
  static jsid halfOpens_id;
  static jsid host_id;
  static jsid idle_id;
  static jsid port_id;
  static jsid spdy_id;
  static jsid ssl_id;

  HttpConnDict(const HttpConnDict&) MOZ_DELETE;

public:
  inline HttpConnDict()
  {
  }

  bool
  Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value");

  bool
  Init(const nsAString& aJSON);

  bool
  ToObject(JSContext* cx, JS::Handle<JSObject*> parentObject, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

private:
  static bool
  InitIds(JSContext* cx);
};
struct HttpConnDictInitializer : public HttpConnDict
{
  inline HttpConnDictInitializer()
  {
    // Safe to pass a null context if we pass a null value
    Init(nullptr, JS::NullHandleValue);
  }
};


} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_NetDashboardBinding_h__
